<!doctype>
<html><head>
<script type='text/javascript' src='js/jquery-1.8.2.min.js'></script>
<script type='text/javascript' src='/js/raphael.js'></script>
<script type='text/javascript' src='js/kibo.js'></script>
<script type='text/javascript' src='/socket.io/socket.io.js'></script>
</head><body style='background:gray'>

<script type='text/javascript' charset='utf8'>

$(document).ready(function() {

var context = new webkitAudioContext();		//webkit browsers only

var local_mode = false;

var min_frequency = 7025000;
var max_frequency = 7125000;
var min_bandpass = 200;
var max_bandpass = 2000;
var rx_frequency = 7030000;		// start out rockbound
var tx_frequency = 7030000;
var frequency_increment = 10;
var sidetone = 440;

var oscillators = {};

function localFrequency(f) {
	if (typeof f === 'number') return f - rx_frequency + sidetone;
	return f;
}

function setFrequency(newfreq) {
//	if (typeof newfreq == 'number') {
//		var df = newfreq - rx_frequency;
//		for (var f in oscillators) {
//			oscillators[f].frequency += df;
//		}
//	}
	rx_frequency = newfreq;
	tx_frequency = newfreq;
	freqtext.attr({text: '' + rx_frequency});
}

function incrementFrequency(amount) {
	if (typeof rx_frequency === 'number') {
		setFrequency(rx_frequency + amount);
	}
}

var socket;

function initSocketIO() {
	socket = io.connect();
	console.log('Socket connected', socket);
	window.setTimeout(function() {
		connection_indicator.attr({fill: '#00ff00', stroke:'#00ff00'});
	}, 500);
	socket.on('startTX', function (data) {
		startTX(localFrequency(data.frequency));
	});
	socket.on('endTX', function (data) {
		endTX(localFrequency(data.frequency));
	});
	socket.on('pong', function(data) {
		var rtt = new Date().getTime() - data.timestamp;
		window.status = 'RTT: ' + rtt + 'ms';
	});
	socket.on('disconnect', function (data) {
		connection_indicator.attr({stroke: 'darkgreen', fill: 'darkgreen'});		
		window.setTimeout(initSocketIO, 200);
	});
	window.setInterval(function() {
		socket.emit('ping', {'timestamp': new Date().getTime()});
	}, 10000);
}

if (!local_mode) initSocketIO();


function startTX(frequency) {
	if (!frequency) return;
	if (typeof frequency != 'number') {
		if (frequency != rx_frequency) return;
		frequency = sidetone;
	}
	else if ((frequency < min_bandpass) || (frequency > max_bandpass)) return;
	rx_indicator.attr({fill: rx_indicator_on, stroke: rx_indicator_on});

	if (oscillators[frequency] != undefined) {
		++oscillators[frequency].users;
	} else {
		osc = context.createOscillator();
		osc.type = 0;
		osc.frequency.value = frequency;
		osc.connect(context.destination);
		osc.noteOn(0);
		oscillators[frequency] = {
			osc: osc,
			users: 1,
			frequency: frequency,
			started: new Date().getTime()
		}
	}
	updateFFT();
}

function endTX(frequency) {
	if (!frequency) return;
	if (typeof frequency != 'number') {
		if (frequency != rx_frequency) return;
		frequency = sidetone;
	}
	else if ((frequency < min_bandpass) || (frequency > max_bandpass)) return;
	rx_indicator.attr({fill: rx_indicator_off, stroke: rx_indicator_off});

	if (!oscillators[frequency]) return;
	if (oscillators[frequency].users <= 1) {
		oscillators[frequency].osc.noteOff(0);
		if (oscillators[frequency].waterfall_block) {
			waterfall_blocks.push(oscillators[frequency].waterfall_block);
		}
		delete oscillators[frequency];
	} else {
		--oscillators[frequency].users;
	}
	updateFFT();
}

function harvestOscillators() {
	var now = new Date().getTime();
	for (var p in oscillators) {
		if ((now - oscillators[p].started) > 5000) {
			oscillators.p[osc].noteOff(0);
			delete oscillators[p];
		}
	}
}
setInterval(harvestOscillators, 1000);

var packet_count = 0;

function start_element() {
	tx_indicator.attr({fill: tx_indicator_on, stroke: tx_indicator_on});
	//txbutton.attr({'stroke-width': button_stroke_tx_on});
	txtext.attr({text: 'ON AIR'});
	if (local_mode) startTX(sidetone);
	else socket.emit('startTX', {'frequency': tx_frequency, 'count': ++packet_count});
}
function end_element() {
	tx_indicator.attr({fill: tx_indicator_off, stroke: tx_indicator_off});
	//txbutton.attr({'stroke-width': button_stroke_tx_off});
	txtext.attr({text: button_text});
	if (local_mode) endTX(sidetone);
	else socket.emit('endTX', {'frequency': tx_frequency, 'count': ++packet_count});
}

var wpm = 15;
var dit_time = Math.floor(1200/wpm);
var dah_time = 3 * dit_time;

var k = new Kibo();
k.down(['tab', 'shift'], function() {
	start_element();
	return false;
}).up(['tab', 'shift'], function() {
	end_element();
	return false;
});



var dah_down = 0;
function send_iambic_dah() {
	if (!dah_down) {
		if (dit_down) process.nextTick(send_iambic_dit);
		return;
	}
	start_element();
	window.setTimeout(wait_after_dah, dah_time);
}
function wait_after_dah() {
	end_element();
	window.setTimeout(send_iambic_dah, dit_time);
}
k.down(['ctrl'], function() {		// iambic dah key
	++dah_down;						// note dah is pressed for decrement in up()
	if (dit_down) return false;		// yield if dit already down
	if (dah_down == 1) send_iambic_dah();
	return false;
}).up(['ctrl'], function() {
	if (dah_down) --dah_down;
	else console.log('dah underflow');
	return false;
});


var dit_down = 0;
function send_iambic_dit() {
	if (!dit_down) {
		if (dah_down) process.nextTick(send_iambic_dah);
		return;
	}
	start_element();
	window.setTimeout(wait_after_dit, dit_time);
}
function wait_after_dit() {
	end_element();
	window.setTimeout(send_iambic_dit, dit_time);
}
k.down(['alt'], function() {		// iambic dit key
	++dit_down;						// note dit is pressed for decrement in up()
	if (dah_down) return false;		// yield if dah already down
	if (dit_down == 1) send_iambic_dit();
	return false;
}).up(['alt'], function() {
	if (dit_down) --dit_down;
	else console.log('dit underflow');
	return false;
});


k.down('up', function() {incrementFrequency(frequency_increment);});
k.down('down', function() {incrementFrequency(-frequency_increment);});
k.down('y', function() {
	var text = prompt('Enter text:', '');
	if (text) {
		socket.emit('send', {frequency: tx_frequency, text: text, wpm: wpm});
	}
});

var face_width = 1 * $(window).width();
var face_height = 1 * $(window).height();
var face_topleft_x = ($(window).width() - face_width)/2;
var face_topleft_y = ($(window).height() - face_height)/2;

var dsp_width = .4 * face_width;
var dsp_height = .9 * face_height;
var dsp_topleft_x = face_topleft_x + .05 * face_width;
var dsp_topleft_y = face_topleft_y + .05 * face_height;

var fft_width = .9 * dsp_width;
var fft_height = .1 * dsp_height;
var fft_margin = (dsp_width - fft_width)/2;
var fft_topleft_x = dsp_topleft_x + fft_margin;
var fft_topleft_y = dsp_topleft_y + fft_margin;

var waterfall_width = fft_width;
var waterfall_topleft_x = fft_topleft_x;
var waterfall_topleft_y = fft_topleft_y + fft_height + .05 * dsp_height;
var waterfall_height = (dsp_topleft_y + dsp_height - fft_margin) - waterfall_topleft_y;

console.log('FFT:', fft_width, fft_height, fft_topleft_x, fft_topleft_y);

var frequency_width = .4 * face_width;
var frequency_height = .05 * face_width;
var frequency_topleft_x = face_topleft_x + .55 * face_width;
var frequency_topleft_y = face_topleft_y + .05 * face_height;

var connection_indicator_width = 50;
var connection_indicator_height = 20;
var connection_indicator_x = frequency_topleft_x;
var connection_indicator_y = face_topleft_y + .2 * face_height;

var indicator_pad = 10;
var tx_indicator_width = 50;
var tx_indicator_height = 20;
var tx_indicator_x = connection_indicator_x + connection_indicator_width + indicator_pad;
var tx_indicator_y = face_topleft_y + .2 * face_height;

var rx_indicator_width = 50;
var rx_indicator_height = 20;
var rx_indicator_x = tx_indicator_x + tx_indicator_width + indicator_pad;
var rx_indicator_y = face_topleft_y + .2 * face_height;

//var knob_radius = .2 * .5 * face_width;
//var knob_center_x = face_topleft_x + .75 * face_width;
//var knob_center_y = face_topleft_y + .4 * face_height;
//var knob_topleft_x = knob_center_x - (knob_radius/2);
//var knob_topleft_y = knob_center_y - (knob_radius/2);

//var tx_button_radius = .08 * face_width;
//var tx_button_center_x = face_topleft_x + (.85 * face_width) - (tx_button_radius/2);
//var tx_button_center_y = face_topleft_y + (.8 * face_height) - (tx_button_radius/2);

var tx_button_width = frequency_width; 
var tx_button_x = frequency_topleft_x;
var tx_button_y = frequency_topleft_y + .8 * waterfall_height;
var tx_button_height = (waterfall_topleft_y + waterfall_height) - tx_button_y;

var button_stroke_tx_on = 20;
var button_stroke_tx_off = 10;
var button_text = 'TX';

var rx_indicator_on = '#00ff00';
var rx_indicator_off = 'darkgreen';
var tx_indicator_on = '#00ff00';
var tx_indicator_off = 'darkgreen';

var face_stroke = 'teal';
var face_fill = 'black'
var button_color = 'red';

var interior_corner_radius = 10;

var paper = Raphael(0, 0, $(window).width(), $(window).height());

var face = paper.rect(face_topleft_x, face_topleft_y, face_width, face_height, 20)
	.attr({stroke: face_stroke, fill: face_fill, 'stroke-width': 10});

var dsp_panel = paper.rect(dsp_topleft_x, dsp_topleft_y, dsp_width, dsp_height, interior_corner_radius)
	.attr({stroke: face_stroke, fill: face_fill});

var fft = paper.rect(fft_topleft_x, fft_topleft_y, fft_width, fft_height)
	.attr({stroke: face_stroke, fill: face_fill});

var fft_bandwidth = 3000;
var fft_numbars = 128;
var fft_active_bars = [];
var fft_bar_width = fft_width / fft_numbars;
var fft_bar_color = 'yellow';

function updateFFT() {
	while (fft_active_bars.length) fft_active_bars.pop().remove();

	var frequency, bar, amplitude;
	for (var f in oscillators) {
		frequency = oscillators[f].frequency;
		if (typeof frequency != 'number') {
			bar = fft_numbars/2;
			amplitude = 1;
		}
		else {
			frequency -= sidetone;
			if (Math.abs(frequency) > fft_bandwidth/2) continue;
			bar = (fft_numbars/2) + fft_numbars * (frequency / fft_bandwidth);
			amplitude = 1 - Math.abs(frequency / (fft_bandwidth/2));
		}
		//bar = Math.floor(bar);
		var x = fft_topleft_x + (bar * fft_bar_width);
		var y = fft_topleft_y + ((1 - amplitude) * fft_height);
		var bar_rect = paper.rect(x, y, 
			fft_bar_width, amplitude * fft_height)
			.attr({stroke: fft_bar_color, fill: fft_bar_color});
		fft_active_bars.push(bar_rect);

		if (!oscillators[f].waterfall_block) {
			oscillators[f].waterfall_block = paper.rect(x, waterfall_topleft_y, fft_bar_width, 1)
			.attr({stroke: fft_bar_color, fill: fft_bar_color});
		}
	}
}

var waterfall = paper.rect(waterfall_topleft_x, waterfall_topleft_y, waterfall_width, waterfall_height)
	.attr({stroke: face_stroke, fill: face_fill});

var waterfall_blocks = [];
var waterfall_y_increment = fft_bar_width;

function addWaterfallBlock(x) {
	var block = paper.rect(x, waterfall_topleft_y, fft_bar_width, fft_bar_width)
			.attr({stroke: fft_bar_color, fill: fft_bar_color});
	waterfall_pixels.push(block);
}

function updateWaterfall() {
	var p = 0;
	while (p<waterfall_blocks.length) {
		var newy = parseInt(waterfall_blocks[p].attr('y')) + waterfall_y_increment;
		if (newy + waterfall_blocks[p].attr('height') > waterfall_topleft_y + waterfall_height) {
			waterfall_blocks[p].remove();
			waterfall_blocks.splice(p,1);
		}
		else waterfall_blocks[p++].attr({y: newy});
	}
	for (var f in oscillators) {
		if (oscillators[f].waterfall_block) {
			var newheight = parseInt(oscillators[f].waterfall_block.attr('height')) + waterfall_y_increment;
			oscillators[f].waterfall_block.attr({height: newheight});
		}
	}
}
window.setInterval(updateWaterfall, 50);


var freqbezel = paper.rect(frequency_topleft_x, frequency_topleft_y, frequency_width, frequency_height, 10)
	.attr({stroke: face_stroke, fill: face_fill});

var bumper_size = .6 * frequency_height;
var bumper_offset = .1 * frequency_height;
var bumpup = paper.path([
	'M', frequency_topleft_x + bumper_size/2 + bumper_offset, frequency_topleft_y + bumper_offset,
	'l', -bumper_size/2, +bumper_size,
	'l', bumper_size, 0,
	'z']).attr({fill: face_stroke, stroke:face_stroke})
	.click(function(e) {
		e.stopPropagation();
		e.preventDefault();
		incrementFrequency(frequency_increment);
	});

var bumpdown = paper.path([
	'M', frequency_topleft_x + frequency_width - bumper_size - bumper_offset, frequency_topleft_y + bumper_offset,
	'l', bumper_size, 0,
	'l', -bumper_size/2, +bumper_size,
	'z']).attr({fill: face_stroke, stroke:face_stroke})
	.click(function(e) {
		e.stopPropagation();
		e.preventDefault();
		incrementFrequency(-frequency_increment);
	});



var freqtext = paper.text(frequency_topleft_x + frequency_width/2, 
		frequency_topleft_y + frequency_height/2, ''+rx_frequency)
	.attr({'font-size':60, stroke: face_stroke, fill:face_stroke})
	.click(function() {
		var newfreq = prompt('Enter frequency:', '' + rx_frequency);
		if (newfreq) {
			if (newfreq.match(/^\d+$/)) newfreq = parseInt(newfreq);
			rx_frequency = newfreq;
			tx_frequency = newfreq;
			freqtext.attr({'text': newfreq});
		}
	});

var connection_indicator = paper.rect(connection_indicator_x, connection_indicator_y, connection_indicator_width, connection_indicator_height, 5)
	.attr({fill: 'darkgreen', stroke: 'darkgreen'});

var connection_legend = paper.text(connection_indicator_x + (connection_indicator_width/2), 
	connection_indicator_y + (connection_indicator_height/2), 'net');

var tx_indicator = paper.rect(tx_indicator_x, tx_indicator_y, tx_indicator_width, tx_indicator_height, 5)
	.attr({fill: 'darkgreen', stroke: 'darkgreen'});

var tx_indicator_legend = paper.text(tx_indicator_x + (tx_indicator_width/2),
	 tx_indicator_y + (tx_indicator_height/2), 'tx');

var rx_indicator = paper.rect(rx_indicator_x, rx_indicator_y, rx_indicator_width, rx_indicator_height, 5)
	.attr({fill: 'darkgreen', stroke: 'darkgreen'});

var rx_indicator_legend = paper.text(rx_indicator_x + (rx_indicator_width/2),
	 rx_indicator_y + (rx_indicator_height/2), 'rx');

//var freqknob = paper.circle(knob_center_x, knob_center_y, knob_radius)
//	.attr({stroke: face_stroke, fill: face_fill});

var txbutton = paper.rect(tx_button_x, tx_button_y, tx_button_width, tx_button_height, 20)
	.attr({stroke: button_color, fill: face_fill, 'stroke-width': button_stroke_tx_off})
	.mousedown(function(e) {
		start_element();
		e.stopPropagation();
		e.preventDefault();
		return false;
	})
	.mouseup(function(e) {
		end_element();
		e.stopPropagation();
		e.preventDefault();
		return false;
	})
	.touchstart(function(e) {
		start_element();
		e.preventDefault();
		return false;
	})
	.touchcancel(function(e) {
		end_element();
		e.stopPropagation();
		e.preventDefault();
		return false;
	})
	.touchend(function(e) {
		end_element();
		e.stopPropagation();
		e.preventDefault();
		return false;
	});

var txtext = paper.text(tx_button_x + tx_button_width/2, tx_button_y + tx_button_height/2, 'TX')
	.attr({'font-size':40, stroke: button_color, fill: button_color})
	.mousedown(function(e) {
		start_element();
		e.preventDefault();
		return false;
	})
	.mouseup(function(e) {
		end_element();
		e.preventDefault();
		return false;
	})
	.touchstart(function(e) {
		start_element();
		e.preventDefault();
		return false;
	})
	.touchcancel(function(e) {
		end_element();
		e.preventDefault();
		return false;
	})
	.touchend(function(e) {
		end_element();
		e.preventDefault();
		return false;
	});

}); 	// document.ready
</script>

<p>Press Tab or Shift for straight key.</p>
<p>Press Control or Alt for iambic keying.</p>




</body></html>
